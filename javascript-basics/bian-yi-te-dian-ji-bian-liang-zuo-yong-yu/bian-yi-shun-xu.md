# ç¼–è¯‘è¿‡ç¨‹

## \(optional\) è¯­è¨€ç±»å‹

* **åŠ¨æ€ç±»å‹è¯­è¨€**ï¼šåœ¨è¿è¡Œè¿‡ç¨‹å½“ä¸­éœ€è¦æ£€æŸ¥æ•°æ®ç±»å‹çš„è¯­è¨€ï¼Œæ¯”å¦‚JS
* **é™æ€ç±»å‹è¯­è¨€**ï¼šå®ƒçš„æ•°æ®ç±»å‹æ˜¯åœ¨ç¼–è¯‘æœŸè¿›è¡Œæ£€æŸ¥çš„ï¼Œä¹Ÿå°±æ˜¯è¯´å˜é‡åœ¨ä½¿ç”¨å‰è¦å£°æ˜å˜é‡çš„æ•°æ®ç±»å‹ï¼Œæ¯”å¦‚C/C++å’ŒJava
* **å¼ºç±»å‹è¯­è¨€**ï¼šä¸€ä¸ªå˜é‡ä¸ç»è¿‡å¼ºåˆ¶è½¬æ¢ï¼Œå®ƒæ°¸è¿œæ˜¯è¿™ä¸ªæ•°æ®ç±»å‹ï¼Œä¸å…è®¸éšå¼çš„ç±»å‹è½¬æ¢ã€‚ä¸¾ä¸ªä¾‹å­ï¼šå¦‚æœä½ å®šä¹‰äº†ä¸€ä¸ªdoubleç±»å‹å˜é‡a,ä¸ç»è¿‡å¼ºåˆ¶ç±»å‹è½¬æ¢é‚£ä¹ˆç¨‹åºint b = aæ— æ³•é€šè¿‡ç¼–è¯‘ã€‚å…¸å‹ä»£è¡¨æ˜¯Javaã€‚
* **å¼±ç±»å‹è¯­è¨€**ï¼šå®ƒä¸å¼ºç±»å‹è¯­è¨€å®šä¹‰ç›¸å,å…è®¸ç¼–è¯‘å™¨è¿›è¡Œéšå¼çš„ç±»å‹è½¬æ¢ï¼Œå…¸å‹ä»£è¡¨C/C++å’ŒJavaScriptã€‚

## ç¼–è¯‘è¿‡ç¨‹

åœ¨ä¼ ç»Ÿçš„ç¼–è¯‘å‹è¯­è¨€å¤„ç†ä¸­ï¼Œä¸€å—å„¿æºä»£ç ï¼Œä½ çš„ç¨‹åºï¼Œåœ¨å®ƒè¢«æ‰§è¡Œ _ä¹‹å‰_ é€šå¸¸å°†ä¼šç»å†ä¸‰ä¸ªæ­¥éª¤ï¼Œå¤§è‡´è¢«ç§°ä¸ºâ€œç¼–è¯‘â€ï¼š

### åˆ†è¯/è¯æ³•åˆ†æ

å°†ä¸€è¿ä¸²å­—ç¬¦æ‰“æ–­æˆï¼ˆå¯¹äºè¯­è¨€æ¥è¯´ï¼‰æœ‰æ„ä¹‰çš„ç‰‡æ®µï¼Œç§°ä¸º tokenï¼ˆè®°å·ï¼‰ã€‚ä¸¾ä¾‹æ¥è¯´ï¼Œè€ƒè™‘è¿™æ®µç¨‹åºï¼š`var a = 2;`ã€‚è¿™æ®µç¨‹åºå¾ˆå¯èƒ½ä¼šè¢«æ‰“æ–­æˆå¦‚ä¸‹ tokenï¼š`var`ï¼Œ`a`ï¼Œ`=`ï¼Œ`2`ï¼Œå’Œ `;`ã€‚ç©ºæ ¼ä¹Ÿè®¸ä¼šè¢«ä¿ç•™ä¸ºä¸€ä¸ª tokenï¼Œè¿™è¦çœ‹å®ƒæ˜¯å¦æ˜¯æœ‰æ„ä¹‰çš„ã€‚

**æ³¨æ„**ï¼š åˆ†è¯å’Œè¯æ³•åˆ†æä¹‹é—´çš„åŒºåˆ«æ˜¯å¾®å¦™å’Œå­¦æœ¯ä¸Šçš„ï¼Œå…¶ä¸­å¿ƒåœ¨äºè¿™äº› token æ˜¯å¦ä»¥ _æ— çŠ¶æ€_ æˆ– _æœ‰çŠ¶æ€_ çš„æ–¹å¼è¢«è¯†åˆ«ã€‚ç®€è€Œè¨€ä¹‹ï¼Œå¦‚æœåˆ†è¯å™¨å»è°ƒç”¨æœ‰çŠ¶æ€çš„è§£æè§„åˆ™æ¥å¼„æ¸…`a`æ˜¯å¦åº”å½“è¢«è€ƒè™‘ä¸ºä¸€ä¸ªä¸åŒçš„ tokenï¼Œè¿˜æ˜¯åªæ˜¯å…¶ä»– token çš„ä¸€éƒ¨åˆ†ï¼Œé‚£ä¹ˆè¿™å°±æ˜¯ è¯æ³•åˆ†æã€‚

### è§£æ

å°†ä¸€ä¸ª token çš„æµï¼ˆæ•°ç»„ï¼‰è½¬æ¢ä¸ºä¸€ä¸ªåµŒå¥—å…ƒç´ çš„æ ‘ï¼Œå®ƒç»¼åˆåœ°è¡¨ç¤ºäº†ç¨‹åºçš„è¯­æ³•ç»“æ„ã€‚è¿™æ£µæ ‘ç§°ä¸ºâ€œæŠ½è±¡è¯­æ³•æ ‘â€ï¼ˆAST â€”â€” Abstract Syntax Treeï¼‰ã€‚

`var a = 2;` çš„æ ‘ä¹Ÿè®¸å¼€å§‹äºç§°ä¸º `VariableDeclaration`ï¼ˆå˜é‡å£°æ˜ï¼‰é¡¶å±‚èŠ‚ç‚¹ï¼Œå¸¦æœ‰ä¸€ä¸ªç§°ä¸º `Identifier`ï¼ˆæ ‡è¯†ç¬¦ï¼‰çš„å­èŠ‚ç‚¹ï¼ˆå®ƒçš„å€¼ä¸º `a`ï¼‰ï¼Œå’Œå¦ä¸€ä¸ªç§°ä¸º `AssignmentExpression`ï¼ˆèµ‹å€¼è¡¨è¾¾å¼ï¼‰çš„å­èŠ‚ç‚¹ï¼Œè€Œè¿™ä¸ªå­èŠ‚ç‚¹æœ¬èº«å¸¦æœ‰ä¸€ä¸ªç§°ä¸º `NumericLiteral`ï¼ˆæ•°å­—å­—é¢é‡ï¼‰çš„å­èŠ‚ç‚¹ï¼ˆå®ƒçš„å€¼ä¸º`2`ï¼‰ã€‚

### ä»£ç ç”Ÿæˆ

è¿™ä¸ªå¤„ç†å°†æŠ½è±¡è¯­æ³•æ ‘è½¬æ¢ä¸ºå¯æ‰§è¡Œçš„ä»£ç ã€‚è¿™ä¸€éƒ¨åˆ†å°†æ ¹æ®è¯­è¨€ï¼Œå®ƒçš„ç›®æ ‡å¹³å°ç­‰å› ç´ æœ‰å¾ˆå¤§çš„ä¸åŒã€‚

æ‰€ä»¥ï¼Œä¸å…¶æ·±é™·ç»†èŠ‚ï¼Œæˆ‘ä»¬ä¸å¦‚ç¬¼ç»Ÿåœ°è¯´ï¼Œæœ‰ä¸€ç§æ–¹æ³•å°†æˆ‘ä»¬ä¸Šé¢æè¿°çš„ `var a = 2;` çš„æŠ½è±¡è¯­æ³•æ ‘è½¬æ¢ä¸ºæœºå™¨æŒ‡ä»¤ï¼Œæ¥å®é™…ä¸Š _åˆ›å»º_ ä¸€ä¸ªç§°ä¸º `a` çš„å˜é‡ï¼ˆåŒ…æ‹¬åˆ†é…å†…å­˜ç­‰ç­‰ï¼‰ï¼Œç„¶ååœ¨ `a` ä¸­å­˜å…¥ä¸€ä¸ªå€¼ã€‚

**æ³¨æ„**ï¼š å¼•æ“å¦‚ä½•ç®¡ç†ç³»ç»Ÿèµ„æºçš„ç»†èŠ‚è¿œæ¯”æˆ‘ä»¬è¦æŒ–æ˜çš„ä¸œè¥¿æ·±åˆ»ï¼Œæ‰€ä»¥æˆ‘ä»¬å°†ç†æ‰€å½“ç„¶åœ°è®¤ä¸ºå¼•æ“æœ‰èƒ½åŠ›æŒ‰å…¶éœ€è¦åˆ›å»ºå’Œå­˜å‚¨å˜é‡ã€‚

### JS

å’Œå¤§å¤šæ•°å…¶ä»–è¯­è¨€çš„ç¼–è¯‘å™¨ä¸€æ ·ï¼ŒJavaScript å¼•æ“è¦æ¯”è¿™åŒºåŒºä¸‰æ­¥å¤æ‚å¤ªå¤šäº†ã€‚ä¾‹å¦‚ï¼Œåœ¨è§£æå’Œä»£ç ç”Ÿæˆçš„å¤„ç†ä¸­ï¼Œä¸€å®šä¼šå­˜åœ¨ä¼˜åŒ–æ‰§è¡Œæ•ˆç‡çš„æ­¥éª¤ï¼ŒåŒ…æ‹¬å‹ç¼©å†—ä½™å…ƒç´ ï¼Œç­‰ç­‰ã€‚

JavaScript å¼•æ“æ²¡æœ‰ï¼ˆåƒå…¶ä»–è¯­è¨€çš„ç¼–è¯‘å™¨é‚£æ ·ï¼‰å¤§æŠŠçš„æ—¶é—´å»ä¼˜åŒ–ï¼Œå› ä¸º JavaScript çš„ç¼–è¯‘å’Œå…¶ä»–è¯­è¨€ä¸åŒï¼Œä¸æ˜¯æå‰å‘ç”Ÿåœ¨ä¸€ä¸ªæ„å»ºçš„æ­¥éª¤ä¸­ã€‚

å¯¹ JavaScript æ¥è¯´ï¼Œåœ¨è®¸å¤šæƒ…å†µä¸‹ï¼Œç¼–è¯‘å‘ç”Ÿåœ¨ä»£ç è¢«æ‰§è¡Œå‰çš„ä»…ä»…å‡ å¾®ç§’ä¹‹å†…ï¼ˆæˆ–æ›´å°‘ï¼ï¼‰ã€‚ä¸ºäº†ç¡®ä¿æœ€å¿«çš„æ€§èƒ½ï¼ŒJS å¼•æ“å°†ä½¿ç”¨æ‰€æœ‰çš„æ‹›æ•°ï¼ˆæ¯”å¦‚ JITï¼Œå®ƒå¯ä»¥æ‡’ç¼–è¯‘ç”šè‡³æ˜¯çƒ­ç¼–è¯‘ï¼Œç­‰ç­‰ï¼‰ï¼Œè€Œè¿™è¿œè¶…å‡ºäº†æˆ‘ä»¬å…³äºâ€œä½œç”¨åŸŸâ€çš„è®¨è®ºã€‚

## ç¼–è¯‘ç‰¹ç‚¹åŠå˜é‡ä½œç”¨åŸŸ

* [ ] The sequence of execution?
* [ ] How does JS Engine compile our code? What's the difference between JS Engine and Interpreter?
* [ ] What is **scoping** and **hoisting**? 
* [ ] How do **function** variables run in JS behind the scene? 
* [ ] What is the **temporal dead zone**?

> **å½“JavaScriptä»£ç æ‰§è¡Œä¸€æ®µå¯æ‰§è¡Œä»£ç \(executable code\)æ—¶ï¼Œä¼šåˆ›å»ºå¯¹åº”çš„æ‰§è¡Œä¸Šä¸‹æ–‡\(execution context\)ã€‚**
>
> å¯¹äºæ¯ä¸ªæ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œéƒ½æœ‰ä¸‰ä¸ªé‡è¦å±æ€§ï¼š
>
> * å˜é‡å¯¹è±¡\(Variable objectï¼ŒVO\)
> * ä½œç”¨åŸŸé“¾\(Scope chain\)
> * this
>
> âš ï¸åŒºåˆ†æ¦‚å¿µï¼š
>
> 1. Scopeï¼šä½œç”¨åŸŸï¼Œå½“å‰æ‰§è¡Œä»£ç **å¯¹å˜é‡çš„è®¿é—®æƒé™** â€”â€” åˆ°æ”¿åºœéƒ¨é—¨åŠäº‹çš„å¾—æ‰¾äººï¼Œæœ‰æ—¶èƒ½åŠæˆæœ‰æ—¶åŠä¸æˆï¼Œå¾—çœ‹ä½ å…³ç³»ç½‘æœ‰å¤šå¼ºå¤§ï¼Œèƒ½ä¸èƒ½æ‰¾åˆ°èƒ½åŠæˆäº‹çš„é‚£ä½å…³é”®äººç‰©ï¼›ä½†æ˜¯åªèƒ½é çˆ¶æ¯ â€” parent nodeé‡Œçš„å˜é‡å¯ä»¥éšä¾¿ç”¨ï¼Œå…„å¼Ÿå§å¦¹é ä¸ä½ â€” sibling nodeä¸å¯ğŸ™…ï¼‰
> 2. Execution Contextï¼šæ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œæ‰“ç¾¤æ¶è¢«è­¦å¯ŸæŠ“æ¥è­¦å±€çš„å½•å£ä¾›çš„ä¸€å¸®äºº/çŠ¯ç½ªå›¢ä¼™ï¼Œ**åŠ¨ä¸€å‘åˆ™ç‰µå…¨èº«**ï¼Œéšä¾¿é—®ä¸€ä¸ªå•¥ä¹Ÿä¸çŸ¥é“ï¼Œéƒ½è¯´è‡ªå·±åªè·Ÿä¸Šå®¶è”ç³»ï¼Œå®ƒå©å’ä»€ä¹ˆå°±åšä»€ä¹ˆï¼Œå…¶ä»–å†…å¹•ä»€ä¹ˆä¹Ÿä¸çŸ¥é“ï¼›ä¸€å®¡å¾—å®¡ä¸€çª
> 3. Call Stackï¼šåŠäº‹å¤„ï¼Œé‡Œé¢å¡æ»¡äº†ç¼–è¯‘å™¨çš„**å¾…åŠäº‹é¡¹/ç­‰å€™å·²ä¹…çš„å®¢æˆ·**ğŸ˜„ ç¼–è¯‘å™¨æŒ‰é¡ºåºä¸€ä¸ªä¸ªè¿›è¡Œå¤„ç†ï¼›æ’é˜Ÿçš„æ˜¯ä¸€æ®µå‡½æ•°æˆ–è€…global execution contextï¼Œäº‹æƒ…åŠå®Œå°±è¢«èµ¶å‡ºå»
> 4. Hoistï¼šå®¢æˆ·è¢«åˆ†æˆä¸‰å…­ä¹ç­‰ï¼Œæœ€çš‡ğŸ‘‘çš„åœ¨ç¼–è¯‘å™¨åˆšå¼€å§‹ä¸Šç­æ—¶å°±è¢«**ä¼˜å…ˆæ¥å¾…**ï¼ŒèŒ¶æ°´ä¼ºå€™ï¼Œå¾—æŠŠå®ƒçš„äº‹æå®Œäº†æ‰èƒ½è®©ä¸‹ä¸€ä½å®¢æˆ·è¿›åŠå…¬å®¤

### Scoping é™æ€ä½œç”¨åŸŸ

**Definition**: â€œWhere does the variable live? â€ â€œHow can I access it?â€ The environment where the variable lives.

Basically for functions, the scope is the variable environment. The scope of a variable is defined by its location within the source code.

#### Scope

There are three types of scopes:

1. **Global scope**
   1. Accessible for all variables
   2. å±äº global variablesï¼Œ
2. **Function/Local scope**
   1. _Function scope is actually a special type of a block scope._
3. **Block scope\(ES6\)**
   1. Only for `let`, `const` variables, and functions\(only in strict mode\) â€” block-scoped
   2. `if`, `with`, `for`, `while`, even empty `{}`!
   3. å½“`var`å˜é‡åœ¨å‡½æ•°å†…éƒ¨è¢«å®šä¹‰æ—¶ï¼Œå³ä½¿nestå¥½å‡ å±‚ï¼Œ`var`å˜é‡ä»åœ¨è¿™ä¸ªå‡½æ•°ä½œç”¨åŸŸ
   4. `const`

![img](https://tva1.sinaimg.cn/large/008i3skNgy1gqh7xiz2xwj31a20mows6.jpg)

åˆ†æ¸…æ¯ä¸ªå˜é‡ï¼ˆåŒ…æ‹¬å‡½æ•°ï¼‰çš„åˆå§‹æ—¶åœ¨å“ªä¸ªscopï¼Œç„¶åæ…¢æ…¢ä¸€å±‚ä¸€å±‚ä»å†…å¾€å¤–ç¿»:facepunch:

#### Scope Chain

Variable Lookupï¼š ç›´çº¿å‘ä¸Šï¼Œå°±è¿‘åŸåˆ™

In JavaScript, variables with the same name can be specified at multiple layers of nested scope. In such a situation, local variables gain priority over global variables. If you declare a local variable and a global variable with the same name, the local variable will take precedence when you use it inside a function or block. This type of behavior is called **shadowing**. Simply put, the inner variable shadows the outer.

Thatâ€™s the exact mechanism used when a JavaScript interpreter is trying to find a particular variable. It starts at the innermost scope being executed at the time, and continues until the first match is found, no matter whether there are other variables with the same name in the outer levels or not.

### Scope Chain VS.  Call Stack

In execution, variables environments are created and pushed into call stack å‹å…¥æ‰§è¡Œä¸Šä¸‹æ–‡æ ˆï¼ˆExecution context stackï¼ŒECSï¼‰

âš ï¸Scope chain has nothing to do with the order of execution/function called.

å®šä¹‰éƒ¨åˆ†ï¼š

* æ ˆï¼šæä¾›ä»£ç è¿è¡Œçš„ç¯å¢ƒï¼Œå­˜å‚¨å„ç§åŸºæœ¬ç±»å‹çš„å˜é‡
* è°ƒç”¨æ ˆï¼šç›¸å½“äºå¼•æ“çš„è°ƒç”¨éƒ¨é—¨ï¼Œä¼šç»´æŠ¤ç¨‹åºæ‰§è¡ŒæœŸé—´çš„ä¸Šä¸‹æ–‡çŠ¶æ€
* å †ï¼šä¸»è¦è´Ÿè´£åƒå¯¹è±¡Objectè¿™ç§å¼•ç”¨å˜é‡ç±»å‹çš„å­˜å‚¨

å¯¹æ¯”ï¼š

* æ ˆï¼ˆç±»æ¯”è´§æ¶ï¼‰ï¼šæ ˆä¸ºè‡ªåŠ¨åˆ†é…çš„å†…å­˜ç©ºé—´ã€‚æ ˆå†…å­˜ä¸­å­˜å‚¨çš„æ•°æ®ä¸€èˆ¬éƒ½æ˜¯å·²çŸ¥å¤§å°çš„ï¼Œç®—æ˜¯ä¸€ç§ç®€å•å‚¨å­˜ã€‚æ ˆä¸­æ•°æ®è¯»å–é€Ÿåº¦ç›¸å¯¹è¾ƒå¿«
* å †ï¼ˆç±»æ¯”ä»“åº“ï¼‰ï¼šå †æ˜¯åŠ¨æ€åˆ†é…çš„å†…å­˜ã€‚å †å†…å­˜ä¸­å­˜å‚¨çš„æ•°æ®åœ¨å¤§å°æ–¹é¢ï¼Œä¼¼ä¹æ²¡æœ‰è§„å®šï¼Œè€Œä¸”ä¸€èˆ¬å¤§å°éƒ½æ˜¯æœªçŸ¥çš„ã€‚å †ä¸­æ•°æ®è¯»å–é€Ÿåº¦ç›¸å¯¹è¾ƒæ…¢ï¼ˆè¦æ‹¿ç€åœ°å€å€¼å»å–æ•°æ®ï¼‰

### æ‰§è¡Œä¸Šä¸‹æ–‡ Variable Environment

There are three types of variable environments:

1. **Function variable environment**
   * å‡½æ•°æ¯æ¬¡æ‰§è¡Œéƒ½ä¼šç”Ÿæˆæ–°çš„ä¸Šä¸‹æ–‡ï¼Œä¸ç®¡æœ‰æ²¡æœ‰è¢«åå¤å£°æ˜
2. **Global variable environment**
3. `eval` function 

#### Executable Code

JavaScript çš„å¯æ‰§è¡Œä»£ç \(executable code\)çš„ç±»å‹ï¼š

1. å…¨å±€ä»£ç 
2. å‡½æ•°ä»£ç 
3. evalä»£ç 

#### Executable Context Stack\(ECS\)

å½“æ‰§è¡Œä¸€ä¸ªå‡½æ•°çš„æ—¶å€™ï¼Œå°±ä¼šåˆ›å»ºä¸€ä¸ªæ‰§è¡Œä¸Šä¸‹æ–‡ï¼Œå¹¶ä¸”å‹å…¥æ‰§è¡Œä¸Šä¸‹æ–‡æ ˆï¼Œå½“å‡½æ•°æ‰§è¡Œå®Œæ¯•çš„æ—¶å€™ï¼Œå°±ä¼šå°†å‡½æ•°çš„æ‰§è¡Œä¸Šä¸‹æ–‡ä»æ ˆä¸­å¼¹å‡ºã€‚

ä¼ªä»£ç ç†è§£ï¼š

```javascript
// ä¼ªä»£ç 

// fun1()
ECStack.push(<fun1> functionContext);

// fun1ä¸­ç«Ÿç„¶è°ƒç”¨äº†fun2ï¼Œè¿˜è¦åˆ›å»ºfun2çš„æ‰§è¡Œä¸Šä¸‹æ–‡
ECStack.push(<fun2> functionContext);

// æ“¦ï¼Œfun2è¿˜è°ƒç”¨äº†fun3ï¼
ECStack.push(<fun3> functionContext);

// fun3æ‰§è¡Œå®Œæ¯•
ECStack.pop();

// fun2æ‰§è¡Œå®Œæ¯•
ECStack.pop();

// fun1æ‰§è¡Œå®Œæ¯•
ECStack.pop();

// javascriptæ¥ç€æ‰§è¡Œä¸‹é¢çš„ä»£ç ï¼Œä½†æ˜¯ECStackåº•å±‚æ°¸è¿œæœ‰ä¸ªglobalContext
```

**A Good Example**

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f();
}
checkscope();
```

è§‚å¯Ÿå®ƒå’Œä¸‹é¢ğŸ‘‡ä¸€æ®µæœ‰ä»€ä¹ˆåŒºåˆ«ï¼š

```javascript
var scope = "global scope";
function checkscope(){
    var scope = "local scope";
    function f(){
        return scope;
    }
    return f;
}
checkscope()();
```

æ¨¡æ‹Ÿç¬¬ä¸€æ®µä»£ç çš„æ‰§è¡Œè¿‡ç¨‹ï¼š

```javascript
ECStack.push(<checkscope> functionContext);
ECStack.push(<f> functionContext);
ECStack.pop();
ECStack.pop();
```

æ¨¡æ‹Ÿç¬¬äºŒæ®µä»£ç çš„æ‰§è¡Œè¿‡ç¨‹ï¼š

```javascript
ECStack.push(<checkscope> functionContext);
ECStack.pop();
ECStack.push(<f> functionContext);
ECStack.pop();
```

âš ï¸å®ƒä»¬æ‰§è¡Œä¸Šä¸‹æ–‡æ ˆçš„é¡ºåºå˜åŒ–ä¸ä¸€æ ·å“¦

### å¥æ³•æå‡ Hoisting

Makes some types of variables accessible/usable in the code before they are actually declared. â€œVariables lifted to the top of their scopeâ€.

**Behind the scenes:**

* Before execution, code is scanned for variable declarations, and for each variable, a new property is created in the **variable environment object**.
* åœ¨global scopeé‡Œå£°æ˜çš„`var`å˜é‡å’Œå‡½æ•°å£°æ˜åœ¨â€œé¢„è§£æâ€**æ—¶ä¼šè¢«hoist**åˆ°å½“å‰å®šä¹‰åŸŸï¼ˆscopeï¼‰çš„æœ€å‰é¢ï¼Œç„¶ååœ¨æŒ‰ç…§é¡ºåºé€è¡Œæ‰§è¡Œä»£ç ï¼›
* åªæå‡å£°æ˜ï¼Œä¸æå‡èµ‹å€¼

**Why Hoisting?**

* Using functions before actual declaration;
* `var` hoisting is just a byproduct of hoisting functions.
* We cannot remove this feature now :anguished:

|  | HOISTED ğŸ‘‡ | INITIAL VALUEğŸ‘‡ | SCOPEğŸ‘‡ |
| :---: | :---: | :---: | :---: |
| **`function` declarations** | YES âœ… | Actual function | Block or Function |
| **`var` variables** | YES âœ… | `undefined` | Function |
| **`let` and `const` variables** | NO â›” | `<uninitialized>, TDZ` | Block |
| **`function` expressions and arrows** | Depends if using `var` or `let/const` | Depends if using `var` or `let/const` | Depends if using `var` or `let/const` |
| Arrow functions |  |  |  |

**Temporal Dead Zone æš‚æ—¶æ€§æ­»åŒº**

The section from the beginning of the block to the actual variable declaration of `let` and `const` global variables are called the **Temporal Dead Zone**.

**Error Message**

For TDZ, we got different error messages when we try to access the unavailable variables: `ReferenceError: Cannot access 'job' before initialization`

For a variable never declared: `ReferenceError: x is not defined`

**Why TDZ?**

* Make it easier to avoid and catch errors: **accessing variables before the declaration is bad practice** and should be avoided;
* Makes `const` variables actually work â€”â€” never reassigned

**Coding Examples**

```javascript
var me = 'Jonas';
let job = 'teacher';
const year = 1991;

console.log(addDecl(2, 3));
console.log(addExpr(2, 3));  // TDZ Uncaught TypeError: addExpr is not a function
console.log(addArrow); // Undefined
console.log(addArrow(2, 3))  


function addDecl(a, b) {
    return a + b;
}

// var: Uncaught TypeError: addExpr is not a function
// Since it is `undefined(2, 3)
var addExpr = function (a, b) {
    return a + b;
};

var addArrow = (a, b) => a + b;
```

```javascript
console.log(addDecl(2, 3));
// console.log(addExpr(2, 3));  // TDZ Uncaught TypeError: addExpr is not a function
// console.log(addArrow); // Undefined
console.log(addArrow(2, 3))  // Uncaught TypeError: addArrow is not a function


function addDecl(a, b) {
    return a + b;
}

// const: Uncaught TypeError: addExpr is not a function
// Since it is `undefined(2, 3)
const addExpr = function (a, b) {
    return a + b;
};

var addArrow = (a, b) => a + b;
```

**Binding**

Letâ€™s first examine the life cycle of `var` variables, which donâ€™t have temporal dead zones:

* When the scope \(its surrounding function\) of a `var` variable is entered, storage space \(a so-called _binding_\) is created for it. The variable is immediately initialized, by setting it to `undefined`.
* When the execution within the scope reaches the declaration, the variable is set to the value specified by the _initializer_ \(an assignment\) â€“ if there is one. If there isnâ€™t, the value of the variable remains `undefined`.

Variables declared via `let` have temporal dead zones, which means that their life cycles look like this:

* When the scope \(its surrounding block\) of a `let` variable is entered, storage space \(a so-called _binding_\) is created for it. The variable remains uninitialized.
* Getting or setting an uninitialized cause a ReferenceError.
* When the execution within the scope reaches the declaration, the variable is set to the value specified by the _initializer_ \(an assignment\) â€“ if there is one. If there isnâ€™t, the value of the variable is set to `undefined`.

## Primitive VS. Reference Values

### Primitive

Inside **call stack** after declaring a variable:

1. Create an unituqe identifier with variable name 
2. A piece of memory will be allocated 
3. The value is stored in memory at the specified address
4. The value stored at the address **is immutable**

When call a variable, actually call its address. Variable holds address. å¯ä»¥ç”¨å¤šä¸ªå˜é‡æŒ‡å‘åŒä¸€åœ°å€ï¼›

å½“ç»™åŸæœ¬ä¸å…¶ä»–å˜é‡æŒ‡å‘åŒä¸€åœ°å€çš„å˜é‡é‡æ–°èµ‹å€¼æ—¶ï¼Œå˜é‡ä¼šæŒ‡å‘æ–°çš„åœ°å€

### Reference

**An new object** is created and stored in **heap**.

The **identifier** of the object points to a piece of address in **call stack**, then the piece of **memory** in the stack points to object in the **heap** by storing its memory\(in heap\) as value.

A piece of memory in the call stack has a reference to the piece of memory in the **heap** which holds an object.

If we assign a new `const` variable with an existing object, the new identifier will point to the same memory as the existing identifier in the call stack which references to the existing object in the **heap**.

:warning:We can modify the new `const` objectâ€™s properties because the `const` only applies to the value of the identifier in the call stack which holds the memory of the object\(with its properties\) in the heap. We just change the value of value in the heap.

:ballot\_box\_with\_check: `const` is immutable only true for **primitive values**, not for **reference** values.

So after changing the values of object in the heap, the value we get using the two identifiers are â€œchangedâ€.

![Example and Diagram](https://tva1.sinaimg.cn/large/008i3skNgy1gqjhtchohyj31bu0n8170.jpg)

> A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.

### æ‹·è´ Copying Objects

ä¸ºä»€ä¹ˆè¦æ‹·è´ï¼Ÿ

```javascript
// Primitive Type
let lastName = 'Williams';
let oldLastName = lastName;
lastName = 'Davis';
console.log(lastName, oldLastName);
// Davis Williams

// Reference Type
const jessica = {
  firstName: 'Jessica',
  lastName: 'Willams',
  age: 27,
};
const marriedJessica = jessica; // copy the reference and point to the same object in heap
marriedJessica.lastName = 'Davis';
console.log('Before marriage:', jessica);
console.log('After marriage: ', marriedJessica);
// Before marriage: {firstName: "Jessica", lastName: "Davis", age: 27}
// After marriage:  {firstName: "Jessica", lastName: "Davis", age: 27}

// marriedJessica = {};
// we cannot change the value in stack: Uncaught TypeError: Assignment to constant variable.
// Different: change property, change the complete object

// -----
// æ·±æ‹·è´ï¼Ÿä¸ï¼æ˜¯æµ…æ‹·è´
// Copying objects
const jessica2 = {
  firstName: 'Jessica',
  lastName: 'Williams',
  age: 27,
  family: ['Alice', 'Bob'],
};
const jessicaCopy = Object.assign({}, jessica2); // A new object is created in the heap and jessicaCopy is created in stack and points to it
jessicaCopy.lastName = 'Davis';
console.log('Before marriage:', jessica2);
console.log('After marriage: ', jessicaCopy);
// Before marriage: {firstName: "Jessica", lastName: "Williams", age: 27}
// After marriage:  {firstName: "Jessica", lastName: "Davis", age: 27}
// But this will not copy the objects inside the object Jessica

// Manipulate object inside the same object -- change both objects
jessicaCopy.family.push('Mary');
jessicaCopy.family.push('John');

// LoadDash -- æ·±æ‹·è´
console.log('Before marriage:', jessica2);
console.log('After marriage: ', jessicaCopy);
```

#### æµ…æ‹·è´ Shallow Copy

Only copy the first-level properties of object and will **not copy the objects inside the object**

```javascript
const [main, , secondary] = restaurant.categories;
console.log(main, secondary);

const temp = main;
// main = secondary;
// secondary = temp;
// console.log(main, secondary);
```

If running `main = secondary; secondary = temp;`, it will return an `Uncaught TypeError: Assignment to constant variable.`, because you modify the identifier of the `const` object.

#### æ·±æ‹·è´ Deep Copy

## More Advanced Stuff

### ä»ECMScriptè§„èŒƒè§£è¯»this

> Types are further subclassified into ECMAScript language types è¯­è¨€ç±»å‹ and specification types è§„èŒƒç±»å‹.
>
> An ECMAScript language type corresponds to values that are directly manipulated by an ECMAScript programmer using the ECMAScript language. The ECMAScript language types are Undefined, Null, Boolean, String, Number, and Object.
>
> A specification type corresponds to **meta-values** that are used within **algorithms** to describe the **semantics** of ECMAScript language constructs and ECMAScript language types. The specification types are Reference, List, Completion, Property Descriptor, Property Identifier, Lexical Environment, and Environment Record.

ä¹Ÿå°±æ˜¯è¯´ï¼Œåœ¨ ECMAScript è§„èŒƒä¸­è¿˜æœ‰ä¸€ç§åªå­˜åœ¨äºè§„èŒƒä¸­çš„ç±»å‹ï¼Œå®ƒä»¬çš„ä½œç”¨æ˜¯ç”¨æ¥æè¿°è¯­è¨€åº•å±‚è¡Œä¸ºé€»è¾‘ï¼Œå…¶ä¸­çš„ Reference ç±»å‹ä¸ this çš„æŒ‡å‘æœ‰ç€å¯†åˆ‡çš„å…³è”ã€‚

> The Reference type is used to explain the behaviour of such operators as delete, typeof, and the assignment operators.
>
> A Reference consists of three components, the base value, the referenced name and the Boolean valued strict reference flag.
>
> The base value is either undefined, an Object, a Boolean, a String, a Number, or an environment record \(10.2.1\). A base value of undefined indicates that **the reference could not be resolved to a binding**. The referenced name is a String. referenced name å°±æ˜¯å±æ€§çš„åç§°

æ‰€ä»¥ Reference ç±»å‹å°±æ˜¯ç”¨æ¥è§£é‡Šè¯¸å¦‚ deleteã€typeof ä»¥åŠèµ‹å€¼ç­‰æ“ä½œè¡Œä¸ºçš„ã€‚

ä¸¾ä¸ªä¾‹å­ï¼š

```javascript
var foo = 1;

// å¯¹åº”çš„Referenceæ˜¯ï¼š
var fooReference = {
    base: EnvironmentRecord,
    name: 'foo',
    strict: false
};
```

### Microtask Queueing and Execution Within The Browser's Event Loop

[Tasks, microtasks, queues and schedules - JakeArchibald.com](https://jakearchibald.com/2015/tasks-microtasks-queues-and-schedules/)

## Reference

[Call Stack æ˜¯ä»€ä¹ˆ? \| æ¥Offer \(laioffer.com\)](https://www.laioffer.com/zh/news/2017-06-22-what-is-call-stack/#:~:text=Call)

